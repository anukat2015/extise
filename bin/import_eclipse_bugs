#!/usr/bin/env ruby
require_relative 'common' and load_extise!

m, n, c, s, t, v, q, z, p = nil, :restrict, true, false, 80, true, false, false, [STDIN]

ARGV.bind_and_parse! to: :locals do
  use '[<options>] [<file>...]'
  opt 'm -m --mylyn[=<path>]'
  opt 'n    --mylyn-mode=(append|delete|restrict)'
  opt 'c -c --[no-]color'
  opt 's -s --[no-]sort'
  opt 't -t --trim[=<length:Integer>]'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
  opt 'z    --stat'
  arg 'p [<path>...]'
end

AutoColor.disable on: self unless c

include BugsEclipseOrg

def import_mylyn_context(a, i = 0, o = options.bound)
  file = File.join o[:m], "#{a}.xml"
  args = [file, "-t#{o[:t] - 2 * i}"]
  %w(verbose sort color).each { |x| o[x[0].to_sym] ? (args << "-#{x[0]}") : (args << "--no-#{x}") }
  args << '-q' if o[:q]
  cmd = "import_mylyn_contexts #{args.reverse * ' '}"
  puts "#{'  ' * i}#{cmd.cyan}" if o[:v] unless o[:q]
  Open3.popen3(File.expand_path cmd, __dir__) do |_, out, error, status|
    out.each_line do |l|
      puts "#{'  ' * i}#{l}"
    end unless o[:q]
    abort error.read unless status.value.to_i.zero?
  end
end

def count_mylyn_context_interactons(d, o = options.bound)
  d.css('attachment').sum do |a|
    next 0 unless a.css('filename').text == Attachment::MYLYN_CONTEXT_FILENAME
    Nokogiri::XML(File.open File.join o[:m], "#{a.css('attachid').text}.xml").css('InteractionEvent').count
  end
end

i = v && !options.default?(:p) ? 1 : 0

p.each do |f|
  d = Nokogiri::XML File.open_or f

  puts "#{f.green}" unless q || i.zero?

  if z
    dump_attribute :bugzilla, d.root.attributes['urlbase'].text, i
    dump_attribute :bugs, d.css('bug').count, i + 1
    dump_attribute :comments, d.css('long_desc').count, i + 1
    dump_attribute :attachments, d.css('attachment').count, i + 1
    dump_attribute :interactions, count_mylyn_context_interactons(d), i + 2 if m
    next
  end

  urlbase = d.root.attributes['urlbase'].text.presence
  version = d.root.attributes['version'].text.presence
  maintainer = d.root.attributes['maintainer'].text.presence

  abort "Invalid URL: #{urlbase}".red  if urlbase != 'https://bugs.eclipse.org/bugs/'
  abort "Invalid version: #{version}".red  if version != '4.4.7'
  abort "Invalid maintainer: #{maintainer}".red  if maintainer != 'webmaster@eclipse.org'

  bugzilla = persist(Bugzilla, urlbase: urlbase) do |r|
    r.version = version
    r.maintainer = maintainer
  end

  dump_record bugzilla, :bugzilla, i

  d.css('bug').each do |b|
    bug = persist(Bug, bugid: b.css('bug_id').text.presence, xml: b) do |r|
      abort "#{Bug}:#{r.bugid} too many reporters".red if b.css('reporter').count != 1
      abort "#{Bug}:#{r.bugid} too many assignees".red if b.css('assigned_to').count != 1

      r.bugzilla = bugzilla
      r.author = persist_user b.css('reporter').text.presence, b.css('reporter')[0].attributes['name'].try(&:text).presence
      r.assignee = persist_user b.css('assigned_to').text.presence, b.css('assigned_to')[0].attributes['name'].try(&:text).presence

      r.creation_ts = b.css('creation_ts').text.presence
      r.short_desc = b.css('short_desc').text
      r.delta_ts = b.css('delta_ts').text.presence
      r.reporter_accessible = b.css('reporter_accessible').text
      r.cclist_accessible = b.css('cclist_accessible').text
      r.classificationid = b.css('classification_id').text.presence
      r.classification = b.css('classification').text.presence
      r.product = b.css('product').text.presence
      r.component = b.css('component').text.presence
      r.version = b.css('version').text.presence
      r.rep_platform = b.css('rep_platform').text.presence
      r.op_sys = b.css('op_sys').text.presence
      r.bug_status = b.css('bug_status').text.presence
      r.resolution = b.css('resolution').text.presence
      r.bug_file_loc = b.css('bug_file_loc').text.presence
      r.status_whiteboard = b.css('status_whiteboard').text.presence
      r.keywords = b.css('keywords').map { |v| v.text.presence }.compact
      r.priority = b.css('priority').text.presence
      r.bug_severity = b.css('bug_severity').text.presence
      r.target_milestone = b.css('target_milestone').text.presence
      r.dependson = b.css('dependson').map { |v| v.text.presence }.compact
      r.everconfirmed = b.css('everconfirmed').text
      r.reporter = b.css('reporter').text.presence
      r.reporter_name = b.css('reporter')[0].attributes['name'].try(&:text).presence
      r.assigned_to = b.css('assigned_to').text.presence
      r.assigned_to_name = b.css('assigned_to')[0].attributes['name'].try(&:text).presence
      r.cc = b.css('cc').map { |v| v.text.presence }.compact
      r.votes = b.css('votes').text.presence
      r.comment_sort_order = b.css('comment_sort_order').text.presence
    end

    dump_record bug, :bug, i + 1
    dump_record bug.author, :author, i + 2
    dump_record bug.assignee, :assignee, i + 2

    b.css('long_desc').each do |c|
      comment = persist(Comment, commentid: c.css('commentid').text.presence, xml: c) do |r|
        abort "#{Comment}:#{r.commentid} too many authors".red if c.css('who').count != 1

        r.bug = bug
        r.author = persist_user c.css('who').text.presence, c.css('who')[0].attributes['name'].try(&:text).presence

        r.comment_count = c.css('comment_count').text.presence
        r.who = c.css('who').text.presence
        r.who_name = c.css('who')[0].attributes['name'].try(&:text).presence
        r.bug_when = c.css('bug_when').text.presence
        r.thetext = c.css('thetext').text
        r.isprivate = c.attributes['isprivate'].text
      end

      dump_record comment, :comment, i + 2
      dump_record comment.author, :author, i + 3
    end

    b.css('attachment').each do |a|
      attachment = persist(Attachment, attachid: a.css('attachid').text.presence, xml: a) do |r|
        abort "#{Attachment}:#{r.attachid} too many attachers".red if a.css('attacher').count != 1

        r.bug = bug
        r.submitter = persist_user a.css('attacher').text.presence, a.css('attacher')[0].attributes['name'].try(&:text).presence

        r.date = a.css('date').text.presence
        r.delta_ts = a.css('delta_ts').text.presence
        r.desc = a.css('desc').text
        r.filename = a.css('filename').text.presence
        r.type = a.css('type').text.presence
        r.size = a.css('size').text.presence
        r.attacher = a.css('attacher').text.presence
        r.attacher_name = a.css('attacher')[0].attributes['name'].try(&:text).presence
        r.isobsolete = a.attributes['isobsolete'].text
        r.ispatch = a.attributes['ispatch'].text
        r.isprivate = a.attributes['isprivate'].text
      end

      dump_record attachment, :attachment, i + 2
      dump_record attachment.submitter, :submitter, i + 3

      interactions = attachment.interactions

      case n.to_sym
      when :append
        puts "#{'  ' * (i + 3)}has #{interactions.count} interactions -> append".magenta if interactions.any?
      when :delete
        puts "#{'  ' * (i + 3)}has #{interactions.count} interactions -> delete all".magenta if interactions.any?
        interactions.destroy_all
      when :restrict
        abort "#{Attachment}:#{attachment.id} has #{interactions.count} interactions -> restrict".red if interactions.any?
      else
        raise
      end

      import_mylyn_context attachment.attachid, i + 3 if m && attachment.filename == Attachment::MYLYN_CONTEXT_FILENAME
    end
  end
end
