#!/usr/bin/env ruby
require_relative 'common' and load_extise! { include Extisimo }

n, w = 4, :thread
c, s, t, v, q = true, false, 80, true, false

ARGV.bind_and_parse! to: :locals do
  use '[<options>]'
  opt 'n    --parallel[=<count:Integer>]'
  opt 'w    --parallel-worker=(process|thread)'
  opt 'c -c --[no-]color'
  opt 's -s --[no-]sort'
  opt 't -t --trim[=<length:Integer>]'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
end

n = 0 unless options.assigned? :n
v, q = false, true unless n.zero?

AutoColor.disable on: self unless c

# NOTE: since original data entities omit milliseconds in their timestamps and in order for unique indices to
# work as intended these milliseconds are automatically computed from identifiers of respective entities

def fix_timestamp(time, unique)
  Time.at time.to_i + (Zlib::crc32(unique.to_s) % 1000).to_f / 1000
end

# NOTE: many users have ambiguous login names, such as 'AJDT-inbox', 'mylyn-triaged', 'emo'
# NOTE: some users have real names such as 'Project inbox', 'Missing name'
# NOTE: user with login name 'eclipse' hides many real users, present as reporter or assignee
# NOTE: user with login name 'bugs.eclipse.org' seems to be a real user

AMBIGUOUS_LOGIN_NAME_PATTERN = /\?|eclipse|inbox|info|mail|triaged/i
AMBIGUOUS_REALNAME_PATTERN = /\?|inbox|missing/i

def persist_user(user)
  l = user.login_name !~ AMBIGUOUS_LOGIN_NAME_PATTERN ? user.login_name : nil
  r = user.realname !~ AMBIGUOUS_REALNAME_PATTERN ? user.realname : nil
  n = "#{l || '?'} / #{r || '?'}"
  u = User.fetch(n).first || User.new(name: n)

  login_names, realnames = Set[l].delete_if(&:nil?), Set[r].delete_if(&:nil?)
  bugs_eclipse_org_users = Set[*u.bugs_eclipse_org_users.to_a] << user
  git_eclipse_org_users = Set[*u.git_eclipse_org_users.to_a]

  loop do
    login_names_size, realnames_size = login_names.size, realnames.size

    # NOTE: login names of bugs.eclipse.org users still pose significant ambiguity,
    # fetch only users with similar real names since duplicates are not a problem here

    if realnames.any?
      b = BugsEclipseOrg::User.where(realname: realnames.to_a)
      login_names.merge b.map(&:login_name).select { |n| n && n !~ AMBIGUOUS_LOGIN_NAME_PATTERN }
      bugs_eclipse_org_users.merge b.to_a
    end

    # NOTE: user names and names of git.eclipse.org users do not pose any ambiguity, fetch
    # users with name exactly matching login names and users with user name similar to real names

    if login_names.any?
      g = GitEclipseOrg::User.where(username: login_names.to_a)
      login_names.merge g.map(&:username).select { |n| n && n !~ AMBIGUOUS_LOGIN_NAME_PATTERN }
      realnames.merge g.map(&:name).select { |n| n && n !~ AMBIGUOUS_REALNAME_PATTERN }
      git_eclipse_org_users.merge g.to_a
    end

    if realnames.any?
      g = GitEclipseOrg::User.where(name: realnames.to_a)
      login_names.merge g.map(&:username).select { |n| n && n !~ AMBIGUOUS_LOGIN_NAME_PATTERN }
      realnames.merge g.map(&:name).select { |n| n && n !~ AMBIGUOUS_REALNAME_PATTERN }
      git_eclipse_org_users.merge g.to_a
    end

    break if login_names.size == login_names_size && realnames.size == realnames_size
  end

  u.eclipse_org_user_names = (login_names + realnames).to_a.sort
  u.bugs_eclipse_org_users = bugs_eclipse_org_users.to_a
  u.git_eclipse_org_users = git_eclipse_org_users.to_a
  u.tap { u.save! }
end

i = 0

# NOTE: import only confirmed, resolved or verified, and fixed bugs

bugs = BugsEclipseOrg::Bug.where(
  everconfirmed: true,
  bug_status: %w(RESOLVED VERIFIED),
  resolution: %w(FIXED)
).order(creation_ts: :asc)

process bugs, count: n, worker: w, progress: !n.zero? do |b|
  abort "#{BugsEclipseOrg::Bug}:#{b.id} inconsistent reporter" if b.reporter != b.author.login_name
  abort "#{BugsEclipseOrg::Bug}:#{b.id} inconsistent assignee" if b.assigned_to != b.assignee.login_name

  reporter = persist_user(b.author)
  assignee = persist_user(b.assignee)
  project = persist(Project, product: b.product, component: b.component)

  # NOTE: keywords of original bugs have very low information value

  task = persist(Task, submitted_at: fix_timestamp(b.creation_ts, b.bugid), reporter_id: reporter.id) do |r|
    r.assignee_id = assignee.id
    r.project_id = project.id
    r.classification = b.classification.downcase.gsub(/[\-\s]+/, '_')
    r.description = b.short_desc
    r.status = b.bug_status.downcase.gsub(/[\-\s]+/, '_')
    r.resolution = b.resolution.try! { downcase.gsub(/[\-\s]+/, '_') }
    r.severity = b.bug_severity.downcase
    r.priority = b.priority.downcase
    r.platform = b.rep_platform
    r.operating_system = b.op_sys.sub(/\s*\(unsup(\.|ported)\)\z/i, '')
    r.project_version = b.version.try! { sub(/(unspecified|\-+)/i, '').presence }
    r.project_milestone = b.target_milestone.try! { sub(/(unspecified|\-+)/i, '').presence }
    r.cc = b.cc
    r.modified_at = fix_timestamp b.delta_ts, b.bugid
    r.bugs_eclipse_org_bugs = [b]
    r.git_eclipse_org_changes = GitEclipseOrg::Change.where bugid: b.bugid
  end

  dump_record task.attributes.merge(class: Task.name, id: task.id, git_eclipse_org_changes_ids: task.git_eclipse_org_changes.pluck(:id)), :task, i
  dump_record task, :task, i
  dump_record reporter, :reporter, i + 1
  dump_record assignee, :assignee, i + 1
  dump_record project, :project, i + 1

  b.comments.order(bug_when: :asc).find_each do |c|
    abort "#{BugsEclipseOrg::Comment}:#{c.id} inconsistent author" if c.who != c.author.login_name

    author = persist_user(c.author)

    # NOTE: original comments do not contain modification timestamp, creation timestamp is used instead

    post = persist(Post, submitted_at: fix_timestamp(c.bug_when, c.commentid), author_id: author.id, task_id: task.id) do |r|
      r.description = c.thetext
      r.modified_at = r.submitted_at
      r.bugs_eclipse_org_comment_id = c.id
    end

    dump_record post, :post, i + 1
    dump_record author, :author, i + 2
  end

  b.attachments.order(date: :asc).find_each do |a|
    abort "#{BugsEclipseOrg::Attachment}:#{a.id} inconsistent author" if a.attacher != a.submitter.login_name

    author = persist_user(a.submitter)

    attachment = persist(Attachment, submitted_at: fix_timestamp(a.date, a.attachid), author_id: author.id, task_id: task.id) do |r|
      r.file = a.filename
      r.type = a.type
      r.description = a.desc
      r.modified_at = fix_timestamp a.delta_ts, a.attachid
      r.bugs_eclipse_org_attachment_id = a.id
    end

    dump_record attachment, :attachment, i + 1
    dump_record author, :author, i + 2
  end
end
