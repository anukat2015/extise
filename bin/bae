#!/usr/bin/env ruby
require_relative 'common'

o, u, n, w, p = nil, :now, 8, :thread, [STDIN]
c, v, q = true, true, false

ARGV.bind_and_parse! to: :locals do
  use '[<options>] [<file>...]'
  opt 'o    --open[=<application>]'
  opt 'u    --until=<time>'
  opt 'n    --parallel[=<count:Integer>]'
  opt 'w    --parallel-worker=(process|thread)'
  opt 'c -c --[no-]color'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
  arg 'p [<path>...]'
end

AutoColor.disable on: self unless c

require 'active_support/all'
require 'active_support/testing/stream'

module Syntax
  attr_accessor :measure_until

  def correlation(t, x, y, options = {})
    u = %i(project projects_by_classification projects_by_product)
    r = %i(subject subjects_by_project user users_by_project)

    options = grab_keys options, [:method, :normalization, :scope, u, r].flatten

    x, y = *[x, y].map { |a| Array.wrap(a).map { |i| "#{t}:#{i}" }}

    m = fetch_values options, :method, optional: true
    n = fetch_values options, :normalization, optional: true
    s = fetch_values options, :scope, optional: true

    s = [options] if s.empty?
    s = s.inject([]) { |a, k, v| a << { k => v }} if s.is_a? Hash

    s.each do |o|
      o = grab_keys o.key?(:global) ? options : o, [u, r].flatten

      [u + r].flatten.each { |k| o[k] = fetch_values o, k, optional: true }

      raise 'both project and subject or user given' if u.select { |k| o[k].present? }.any? && r.select { |k| o[k].present? }.any?
      raise 'project already scoped' if o[:project].present? && o[:projects_by_classification].present?
      raise 'project already scoped' if o[:project].present? && o[:projects_by_product].present?
      raise 'both subject and user given' if o[:subject].present? && o[:user].present?
      raise 'subject already scoped' if o[:subject].present? && o[:subjects_by_project].present?
      raise 'user already scoped' if o[:user].present? && o[:users_by_project].present?

      if u.select { |k| o[k].any? }.any?
        p = ['ucor', *pack_values(o, u), '--no-verbose', { parallel: true, silent: true }]
      else
        p = ['rcor', *pack_values(o, r), '--no-verbose', { silent: true }]
      end

      (m.any? ? m : [nil]).each do |method|
        x.each do |a|
          y.each do |b|
            (n.any? ? n : %w(raw)).each do |normalization|
              p = p.dup.insert 1, *[a, b].map { |i| normalization.to_s == 'raw' ? i : "#{i}:#{normalization}" }
              p.insert 3, pack_value(method: method) if method
              run *p
            end
          end
        end
      end
    end
  end

  alias_method :correlate, :correlation

  def histogram(*args)
    args.select { |a| a =~ /\A\s*--/ }.tap { |u| raise 'direct options not allowed' if u.any? }
    run 'rhist', *(args.size == 1 ? ['--eval', "'#{args.first}'"] : args.flatten).map(&:to_s), silent: true
  end

  def measure(options = {})
    options = grab_keys options, duals: %i(targets metrics normalizations), keys: %i(until)

    fetch_values(options, :targets).each do |target|
      fetch_values(options, :metrics).each do |metric|
        run 'measure', target, metric, pack_value(until: options[:until] || measure_until || :now), parallel: true, silent: false
        fetch_values(options, :normalizations, optional: true).each do |normalization|
          run 'normalize', target, metric, pack_value(method: normalization), parallel: true, silent: false
        end
      end
    end
  end

  def normalize(options = {})
    options = grab_keys options, duals: %i(targets metrics methods)

    fetch_values(options, :targets).each do |target|
      fetch_values(options, :metrics).each do |metric|
        fetch_values(options, :methods).each do |method|
          run 'normalize', target, metric, pack_value(method: method), parallel: true, silent: false
        end
      end
    end
  end

  private

  def grab_keys(options, keys: nil, duals: nil)
    options, keys = options.dup, keys + duals.flat_map { |k| [k.to_s.singularize.to_sym, k.to_s.pluralize.to_sym] }
    unknown = (keys - options.keys)
    raise "unrecognized option#{'s' if unknown.size > 1} #{unknown * ', '}" unless unknown.size.zero?
    options
  end

  def fetch_values(options, key, optional: false)
    multiple, single = key.to_s.pluralize.to_sym, key.to_s.singularize.to_sym
    raise("#{single} already given") if options.key?(single) && options.key?(multiple)
    values = Array.wrap options.fetch(multiple, options.fetch(single), [])
    optional || values.any? ? values : raise("no #{single} given")
  end

  alias_method :fetch_value, :fetch_values

  def pack_values(options, keys = options.keys)
    keys.select { |k| options[k].present? }.map.shelljoin do |k|
      v = options[k] * ','
      "--#{k.to_s.tr '_', '-'}=#{v =~ /[\w\s\-:.,]/ ? "'#{v}'" : v.shellescape}"
    end
  end

  alias_method :pack_value, :pack_values
end

class Round
  include ActiveSupport::Testing::Stream

  attr_accessor :file, :options

  def initialize(file, options = {})
    self.file, self.options = file.dup, options.dup
    AutoColor.disable on: self unless self.options[:color]
  end

  def load!
    space, round = Object.new, self
    space.define_singleton_method(:run) { |*a| round.run *a }
    space.singleton_class.include Syntax
    space.measure_until = options[:until]
    space.instance_eval { load File.expand_path '../../Extisefile', __FILE__ }
    SafeEval::IO.read_and_safe_eval File.open_or(file), context: space
    index_screenshots
    true
  end

  def run(*a)
    a = a.flatten.compact
    a, o = *(a.last.is_a?(Hash) ? [a[0..-2], a.last] : [a, {}])
    a += %W(--parallel=#{options[:parallel]} --parallel-worker=#{options[:parallel_worker]}) if o[:parallel]
    a.insert a[-1] =~ /\A--(no-)verbose/ ? -2 : -1, '--color'
    c, t, f = a * ' ', Time.now.strftime('%Y%m%d-%H%M%S-%L'), file.is_a?(IO) ? nil : File.basename(file, '.rb')
    @log_directory ||= File.expand_path File.join(%W(.. .. log #{t}#{'_' + f if f})), __FILE__
    FileUtils.mkpath @log_directory
    l = File.join @log_directory, "#{t}_#{a[0].split(/\s+/, 2)[0]}.log"
    File.write l, "#{t.black}\n\n#{c.white}\n\n"
    p = a.reject { |x| x =~ /\A--(parallel|(no-)?(color|sort|verbose)|trim|quiet)/ }
    p << 'â€¦' if p.size != a.size
    begin
      puts "#{p * ' '}".cyan unless options[:quiet]
      r = "#{File.expand_path File.join(%W(.. #{c})), __FILE__} 2>&1 | tee -a #{l}; exit ${PIPESTATUS[0]}"
      q = o.fetch(:silent, true) || options[:quiet] || !options[:verbose]
      s = (q ? quietly { system(r) } : system(r)).tap do |s|
        puts s ? 'success'.green : 'failure'.red if !options[:quiet] && options[:verbose]
      end
    ensure
      File.write l, File.read(l).gsub(/\n\s*\r.+\r\s*/, $/ * 2)
      take_screenshot t, c, l, s
    end
  end

  private

  def index_screenshots
    return unless @screenshots
    m = @screenshots.map { |s| s[:command].length }.max
    t = "#{File.dirname @screenshot_directory}"
    i = @screenshots.map { |s|
      l = "#{s[:time].black} #{s[:command].ljust(m).white} #{s[:status] ? 'success'.green : 'failure'.red }"
      "<a href=\"#{File.basename s[:screenshot]}\" style=\"text-decoration: none\">#{Colored.decolorize l, escape: Colored::HTML}</a>"
    } * $/
    h = File.join(@screenshot_directory, 'index.html')
    File.write h, build_screenshot(t, i)
    `open #{"-a #{options[:open]}" if options[:open].is_a? String} -g #{h}` if options[:open]
  end

  def build_screenshot(t, c)
    <<-HTML.strip_heredoc.sub(/<%\s*title\s*%>/, t).sub(/<%\s*content\s*%>/, c)
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="utf-8">
          <title><% title %></title>
        </head>
        <body style="margin: 1rem; font-size: 14px">
          <pre style="display: inline-block; margin: 0; padding: 1rem; background: #000; color: #bbb"><% content %></pre>
        </body>
      </html>
    HTML
  end

  def take_screenshot(t, c, l, s)
    c, o = c.gsub(/\s--(no-)?color(\s|\z)/, ' ').strip, File.read(l)
    File.write l, Colored.decolorize(o)
    return unless options[:color]
    @screenshot_directory ||= File.join(File.dirname(l), 'screenshots')
    FileUtils.mkpath @screenshot_directory
    h = File.join @screenshot_directory, "#{File.basename(l)}.html"
    (@screenshots ||= []) << { time: t, command: c, log: l, status: s, screenshot: h }
    File.write h, build_screenshot("#{t} #{c}", Colored.decolorize(o, escape: Colored::HTML))
  end
end

h = {
  open: o,
  until: u,
  parallel: n,
  parallel_worker: w,
  color: c,
  verbose: v,
  quiet: q
}

p.each do |f|
  inform f if v && !q && !f.is_a?(IO)

  Round.new(f, h).load!
end
