#!/usr/bin/env ruby
require_relative 'common' and load_extise!

m, d, n, w = :unit, nil, 4, :thread
c, s, t, v, q, r = true, false, 80, true, false, nil

ARGV.bind_and_parse! to: :locals do
  use '[<options>] <project>'
  opt 'm -m --match=(method|unit|type)'
  opt 'd -d --directory=<path>'
  opt 'n    --parallel[=<count:Integer>]'
  opt 'w    --parallel-worker=(process|thread)'
  opt 'c -c --[no-]color'
  opt 's -s --[no-]sort'
  opt 't -t --trim[=<length:Integer>]'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
  arg 'r <repository>'
end

m = m.to_sym
d ||= File.expand_path('../../../data/git.eclipse.org', __FILE__)
n = 0 unless options.assigned? :n
v, q = false, true unless n.zero?

AutoColor.disable on: self unless c

include Extisimo

#TODO method pairing is not effective, all Elements (methods also) are exactly identified
# by "offset+length in file at commit" not name, but methods in interactions' structure_handle
# are identified by name and params list (and this list is stripped in parse_structure_handle)
#TODO parse_structure_handle also ignores constants and therefore possible methods in anonymous
# classes used in constant field declarations

def parse_structure_handle(h)
  d, p, n, e = *h[1..-1].split(/&lt;|\{|\[/)
  return unless n && e
  f = File.join d, p.split(/\./), n
  e = File.join e.sub(/\^.*\z/, '').sub(/~[^;]+;.*\z/, '').split(/~/) if e
  { directory: d, package: p, name: n, file: f, element: e }
end

repository = Repository.find_by name: r

abort "#{Repository}:? not found by #{r}".red unless repository

dump_record repository, :repository

# NOTE: command, preference, and attention kinds are completely missing from original data
# NOTE: navigation does not hold any information value in original data and can be ignored
# NOTE: interaction delta in original data is always blank and therefore can be ignored
# NOTE: select only interactions with non empty structure handle

interactions = BugsEclipseOrg::Interaction.joins(attachment: [extisimo_attachment: [task: [project: :repositories]]]).where(
  Repository.table_name => { id: repository },
  kind: %w(command edit selection),
  structure_kind: %w(java),
  originid: %w(
    org.eclipse.jdt.ui.ClassFileEditor
    org.eclipse.jdt.ui.CompilationUnitEditor
    org.eclipse.jdt.ui.PackageExplorer
  )
).where.not(structure_handle: nil).order(start_date: :asc)

previous_session = nil

process interactions, count: n, worker: w, progress: !n.zero? do |i|
  attachment = i.attachment.extisimo_attachment
  user = attachment.author
  commits = Extisimo::Commit.where(author: user).where('submitted_at > ?', i.start_date).order(submitted_at: :asc)

  # NOTE: consider consecutive commits A, B, C where A and C have the same author and B is authored by someone else,
  # and a session identified by commit C is created, then C is revision commit, B is original commit, and A is a commit
  # by the same author previous to revision, the session is then bounded by A and C

  previous, revision = *commits.limit(3)

  # NOTE: skip all interactions of initial session, i.e. ignore all unbounded sessions

  next unless previous

  abort "#{BugsEclipseOrg::Interaction}:#{i.id} revision commit not found".red unless revision

  session = persist(Session, user: user, revision_commit: revision) do |r|
    r.previous_commit = previous
    r.previous_identifier = previous.identifier
    r.revision_identifier = revision.identifier
    r.started_at = previous.submitted_at
    r.finished_at = revision.submitted_at
  end

  dump_record previous_session = session, :session, 1 unless previous_session == session

  handle = parse_structure_handle i.structure_handle

  # NOTE: skip interactions without element specified in structure handle

  unless handle
    warn "#{BugsEclipseOrg::Interaction}:#{i.id} missing data in structure handle".magenta
    next
  end

  # NOTE: crop node paths to match elements according to element type during node extraction

  path = handle[:element]
  path = path.sub(/\/.*\z/, '') if m == :unit
  path = path.sub(/\/[a-z].*\z/, '') if m == :type

  # NOTE: skip possible top level package-private classes (this should not affect rename refactorings)

  next if m == :unit && File.basename(handle[:file], '.java') != path

  # NOTE: find potential elements by previous commit since interactions were most likely done on such files
  # NOTE: use file path suffix since file paths in interactions are relative to projects not to repository

  relation = Element.where(commit: previous).where('file LIKE ?', "%#{handle[:file]}")
  elements = relation.where(path: path).all
  element = elements.first

  # NOTE: skip selections with no modifications, i.e. with missing elements extracted from commit

  next if element.nil? && i.kind == 'selection'

  # NOTE: skip interactions for elements unmatched by file, i.e. completely unmatchable interactions

  next if element.nil? && relation.count.zero?

  abort "#{BugsEclipseOrg::Interaction}:#{i.id} element not found".red unless element
  abort "#{BugsEclipseOrg::Interaction}:#{i.id} too many elements".red if elements.size > 1

  interaction = persist(Extisimo::Interaction, started_at: i.start_date, element: element, session: session) do |r|
    r.attachment = attachment
    r.kind = i.kind
    r.finished_at = i.end_date
    r.bugs_eclipse_org_interaction_id = i.id
  end

  dump_record interaction, :interaction, 2
end
