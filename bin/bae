#!/usr/bin/env ruby
require_relative 'common'

u, n, w, p = :now, 4, :thread, [STDIN]
c, v, q = true, true, false

ARGV.bind_and_parse! to: :locals do
  use '[<options>] [<file>...]'
  opt 'u    --until=<time>'
  opt 'n    --parallel[=<count:Integer>]'
  opt 'w    --parallel-worker=(process|thread)'
  opt 'c -c --[no-]color'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
  arg 'p [<path>...]'
end

AutoColor.disable on: self unless c

require 'active_support/all'
require 'active_support/testing/stream'

module Syntax
  attr_accessor :measure_until

  def correlation(t, x, y, options = {})
    x, y = *[x, y].map { |a| Array.wrap(a).map { |i| "#{t}:#{i}" }}

    m = fetch_values options, :method, optional: true
    n = fetch_values options, :normalization, optional: true

    o = %i(subject subjects_by_project user users_by_project)
    raise 'project given with no effect' if options[:project] && !o.select { |k| options[k] }.empty?
    raise 'subject already given' if options[:subject] && options[:user]
    raise 'subject already scoped' if options[:subject] && options[:subjects_by_project]
    raise 'user already scoped' if options[:user] && options[:users_by_project]

    if options[:project]
      p = ['ucor', "--project=#{options[:project]}", '--no-verbose']
      o = { parallel: true, silent: true }
    else
      p = ['rcor', *o.map { |k| "--#{k}=#{options[k]}" if options[k] }, '--no-verbose']
      o = { silent: true }
    end

    (m.any? ? m : [nil]).each do |method|
      x.each do |a|
        y.each do |b|
          (n.any? ? n : %w(raw)).each do |normalization|
            c = p.dup.insert 1, *[a, b].map { |i| normalization.to_s == 'raw' ? i : "#{i}:#{normalization}" }
            c.insert 3, "--method=#{method}" if method
            run *c, o
          end
        end
      end
    end
  end

  alias_method :correlate, :correlation

  def histogram(*args)
    run 'rhist', *(args.size == 1 ? ['--eval', "'#{args.first}'"] : args.flatten).map(&:to_s), silent: true
  end

  def measure(options = {})
    fetch_values(options, :targets).each do |target|
      fetch_values(options, :metrics).each do |metric|
        run 'measure', target, metric, "--until=#{options[:until] || measure_until || :now}", parallel: true, silent: false
        fetch_values(options, :normalizations, optional: true).each do |normalization|
          run 'normalize', target, metric, "--method=#{normalization}", parallel: true, silent: false
        end
      end
    end
  end

  def normalize(options = {})
    fetch_values(options, :targets).each do |target|
      fetch_values(options, :metrics).each do |metric|
        fetch_values(options, :methods).each do |method|
          run 'normalize', target, metric, "--method=#{method}", parallel: true, silent: false
        end
      end
    end
  end

  private

  def fetch_values(options, key, optional: false)
    multiple, single = key.to_s.pluralize.to_sym, key.to_s.singularize.to_sym
    raise("#{single} already given") if options.key?(multiple) && options.key?(single)
    values = Array.wrap options.fetch(multiple, [])
    values = [options[single]] if options.key?(single) && values.empty?
    optional || values.flatten.compact.any? ? values.flatten : raise("no #{single} given")
  end
end

class Round
  include ActiveSupport::Testing::Stream

  attr_accessor :file, :options

  def initialize(file, options = {})
    self.file, self.options = file.dup, options.dup
    AutoColor.disable on: self unless self.options[:color]
  end

  def load!
    space, round = Object.new, self
    space.define_singleton_method(:run) { |*a| round.run *a }
    space.singleton_class.include Syntax
    space.measure_until = options[:until]
    space.instance_eval { load File.expand_path '../../Extisefile', __FILE__ }
    SafeEval::IO.read_and_safe_eval File.open_or(file), context: space
    index_screenshots
    true
  end

  def run(*a)
    a = a.flatten.compact
    a, o = *(a.last.is_a?(Hash) ? [a[0..-2], a.last] : [a, {}])
    a += %W(--parallel=#{options[:parallel]} --parallel-worker=#{options[:parallel_worker]}) if o[:parallel]
    a.insert a[-1] =~ /\A--(no-)verbose/ ? -2 : -1, '--color'
    c, t, f = a * ' ', Time.now.strftime('%Y%m%d-%H%M%S-%L'), file.is_a?(IO) ? nil : File.basename(file, '.rb')
    @log_directory ||= File.expand_path File.join(%W(.. .. log #{t}#{'_' + f if f})), __FILE__
    FileUtils.mkpath @log_directory
    l = File.join @log_directory, "#{t}_#{a[0].split(/\s+/, 2)[0]}.log"
    File.write l, "#{t.black}\n\n#{c.white}\n\n"
    p = a.reject { |x| x =~ /\A--(parallel|(no-)?(color|sort|verbose)|trim|quiet)/ }
    p << 'â€¦' if p.size != a.size
    begin
      puts "#{p * ' '}".cyan unless options[:quiet]
      r = "#{File.expand_path File.join(%W(.. #{c})), __FILE__} 2>&1 | tee -a #{l}; exit ${PIPESTATUS[0]}"
      q = o.fetch(:silent, true) || options[:quiet] || !options[:verbose]
      s = (q ? quietly { system(r) } : system(r)).tap do |s|
        puts s ? 'success'.green : 'failure'.red if !options[:quiet] && options[:verbose]
      end
    ensure
      File.write l, File.read(l).gsub(/\n\s*\r.+\r\s*/, $/ * 2)
      take_screenshot t, c, l, s
    end
  end

  private

  def index_screenshots
    return unless @screenshots
    m = @screenshots.map { |s| s[:command].length }.max
    t = "#{File.dirname @screenshot_directory}"
    i = @screenshots.map { |s|
      l = "#{s[:time].black} #{s[:command].ljust(m).white} #{s[:status] ? 'success'.green : 'failure'.red }"
      "<a style=\"text-decoration: none\" href=\"#{File.basename s[:screenshot]}\">#{Colored.decolorize l, escape: Colored::HTML}</a>"
    } * $/
    File.write File.join(@screenshot_directory, 'index.html'), build_screenshot(t, i)
  end

  def build_screenshot(t, c)
    <<-HTML.strip_heredoc.sub(/<%\s*title\s*%>/, t).sub(/<%\s*content\s*%>/, c)
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="utf-8">
          <title><% title %></title>
        </head>
        <body style="margin: 1rem; font-size: 14px">
          <pre style="display: inline-block; margin: 0; padding: 1rem; background: #000; color: #bbb"><% content %></pre>
        </body>
      </html>
    HTML
  end

  def take_screenshot(t, c, l, s)
    c, o = c.gsub(/\s--(no-)?color(\s|\z)/, ' ').strip, File.read(l)
    File.write l, Colored.decolorize(o)
    return unless options[:color]
    @screenshot_directory ||= File.join(File.dirname(l), 'screenshots')
    FileUtils.mkpath @screenshot_directory
    h = File.join @screenshot_directory, "#{File.basename(l)}.html"
    (@screenshots ||= []) << { time: t, command: c, log: l, status: s, screenshot: h }
    File.write h, build_screenshot("#{t} #{c}", Colored.decolorize(o, escape: Colored::HTML))
  end
end

o = Hash[%i(until parallel parallel_worker color verbose quiet).zip [u, n, w, c, v, q]]

p.each do |f|
  inform f if v && !q && !f.is_a?(IO)
  Round.new(f, o).load!
end
