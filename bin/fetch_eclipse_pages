#!/usr/bin/env ruby
require_relative 'common' and load_extise! { require 'selenium-webdriver' }

o, n, w, p = nil, 4, :thread, [STDIN]
c, v, q = true, false, false

ARGV.bind_and_parse! to: :locals do
  use '[<options>] [<file>...]'
  opt 'o -o --output=<path>'
  opt 'n    --parallel[=<count:Integer>]'
  opt 'w    --parallel-worker=(process|thread)'
  opt 'c -c --[no-]color'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
  arg 'p [<path>...]'
end

n = 0 unless options.assigned? :n
v, q = false, true unless n.zero?

AutoColor.enable on: self, colored: c, colorings: {
  /\A *(bug|change): \d+/ => -> (s, _) { s.sub(/(bug|change): (\d+)/, "#{'\1'.blue}: #{'\2'.yellow}") }
}

i = v && !options.default?(:p) ? 1 : 0

FileUtils.mkpath bugs_directory = (o || File.join(BugsEclipseOrg::DIRECTORY, 'eclipse')) + '-bugs'
FileUtils.mkpath changes_directory = (o || File.join(GitEclipseOrg::DIRECTORY, 'eclipse')) + '-changes'

p.each do |f|
  d = Nokogiri::XML File.open_or f

  inform f unless q || i.zero?

  process d.css('bug'), count: n, worker: w, progress: !n.zero? do |b|
    bug_id = b.css('bug_id').text.strip
    url = "https://bugs.eclipse.org/bugs/show_bug.cgi?id=#{bug_id}"
    file = File.join bugs_directory, "#{bug_id}.html"

    puts "#{'  ' * i}bug: #{bug_id}" unless q

    next if File.exist? file

    content = `curl -sS #{url}`

    File.write file, content

    driver = nil

    begin
      Nokogiri::XML(content).css('#field_container_see_also').css('a').each do |a|
        next if a.text !~ /\s*Gerrit\s+Change\s*/

        driver ||= Selenium::WebDriver.for :phantomjs

        url, change_id = a['href'], a['href'].match(/(?<change_id>\d+)\/?\z/).to_a[1]
        file = File.join changes_directory, "#{change_id}.html"

        unless url && change_id
          warn "#{BugsEclipseOrg::Bug}:#{bug_id} change not found"
          next
        end

        puts "#{'  ' * (i + 1)}change: #{change_id}" unless q

        next if File.exist? file

        driver.navigate.to url
        wait = Selenium::WebDriver::Wait.new timeout: 30.seconds
        wait.until { driver.find_element(class: 'screen').displayed? }
        content = driver.page_source

        File.write file, content
      end
    ensure
      driver.try! :quit
    end
  end
end
