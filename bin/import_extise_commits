#!/usr/bin/env ruby
require_relative 'common' and load_extise!

d, n, w = nil, 4, :thread
c, s, t, v, q, r = true, false, 80, true, false, nil

ARGV.bind_and_parse! to: :locals do
  use '[<options>] <repository>'
  opt 'd -d --directory=<path>'
  opt 'n    --parallel[=<count:Integer>]'
  opt 'w    --parallel-worker=(process|thread)'
  opt 'c -c --[no-]color'
  opt 's -s --[no-]sort'
  opt 't -t --trim[=<length:Integer>]'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
  arg 'r <repository>'
end

d ||= File.expand_path('../../../data/git.eclipse.org', __FILE__)
n = 0 unless options.assigned? :n
v, q = false, true unless n.zero?

AutoColor.disable on: self unless c

include Extisimo

# NOTE: since the sum of interactions is far greater than the sum commits,
# we first process commits and leave interactions for later processing

repository = Repository.find_by name: r

abort "#{Repository}:? not found by #{r}".red unless repository

dump_record repository, :repository

path = File.join d, repository.name
git = Rugged::Repository.new path
sort = Rugged::SORT_DATE | Rugged::SORT_REVERSE

# NOTE: always process master commits only

git.checkout 'master'

process git.walk('HEAD', sort).to_a, count: n, worker: w, progress: !n.zero? do |c|

  # NOTE: skip first commit and all merge commits

  next if c.parents.count != 1

  author = User.joins(:bugs_eclipse_org_user).find_by 'login_name = ? OR realnames @> ?', c.author[:name], "{#{c.author[:name]}}"

  # NOTE: skip commits for users who can not be identified, i.e. with no tasks or interactions

  unless author
    warn "#{User}:? not found by #{c.author[:name]}".magenta
    next
  end

  commit = persist(Commit, repository: repository, identifier: c.oid) do |r|
    r.author = author
    r.submitted_at = c.time.utc
  end

  dump_record commit, :commit, 1

  # NOTE: since each commit includes all affected elements both original and revision files need to be considered

  files = c.parents.first.diff(c).deltas.map { |d| [d.old_file, d.new_file] }.flatten

  # NOTE: select only Java files to process

  files.select! { |f| f[:oid] !~ /0{40}/ && !f[:path].ends_with?('package-info.java') && f[:path].end_with?('.java') }

  next if files.empty?

  # NOTE: extract Java type declarations for all files at once

  extractor = 'TypePositionExtractor'
  data = Extise::Data.pack_inputs files.inject([]) { |a, f| a << [f[:oid], git.lookup(f[:oid]).content] }

  puts "#{'  ' * 2}" << "#{Extise.command extractor} < â€¦".cyan if v unless q

  blocks = Extise.stream(function: extractor, input: data) do |o|
    Extise::Data.parse_blocks(o).group_by { |b| b[:id] }
  end

  abort("#{Commit}:#{commit.id} elements extraction failed".red) if blocks === false
  abort "#{Commit}:#{commit.id} no elements extracted".red if blocks.empty?
  abort "#{Commit}:#{commit.id} some elements not extracted".red if blocks.count != files.count

  files.each do |f|
    id = f[:oid]

    # NOTE: select only top level Java type declarations

    blocks[id].select! { |b| b[:path] !~ /\// }

    if blocks[id].empty?
      warn "#{Commit}:#{commit.id} no suitable elements in #{f[:path]}".magenta
      next
    end

    blocks[id].each do |b|
      element = persist(Element, commit: commit, identifier: f[:oid], path: b[:path]) do |r|
        r.file = f[:path]
        r.offset = b[:offset]
        r.length = b[:length]
        r.line = b[:line]
      end

      dump_record element, :element, 2
    end
  end
end
