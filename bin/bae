#!/usr/bin/env ruby
require_relative 'common'

u, n, w, p = :now, 4, :thread, [STDIN]
c, v, q = true, true, false

ARGV.bind_and_parse! to: :locals do
  use '[<options>] [<file>...]'
  opt 'u    --until=<time>'
  opt 'n    --parallel[=<count:Integer>]'
  opt 'w    --parallel-worker=(process|thread)'
  opt 'c -c --[no-]color'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
  arg 'p [<path>...]'
end

AutoColor.disable on: self unless c

require 'active_support/all'

module Syntax
  attr_accessor :measure_until

  def correlation(x, y, options = {})
    c = [x, y]
    c = c << "--method=#{options[:method]}" if options[:method]
    o = %i(subject subjects_by_project user users_by_project)
    raise 'project given with no effect' if options[:project] && !o.select { |k| options[k] }.empty?
    raise 'subject already given' if options[:subject] && options[:user]
    raise 'subject already scoped' if options[:subject] && options[:subjects_by_project]
    raise 'user already scoped' if options[:user] && options[:users_by_project]
    if options[:project]
      run 'ucor', *c, "--project=#{project}", '--no-verbose', parallel: true, silent: true
    else
      run 'rcor', *c, *o.map { |k| "--#{k}=#{options[k]}" }, '--no-verbose', silent: true
    end
  end

  alias_method :correlate, :correlation

  def histogram(*args)
    run 'rhist', *(args.size == 1 ? ['--eval', args.first] : args).map(&:to_s), silent: true
  end

  def measure(options = {})
    fetch_values(options, :targets).each do |target|
      fetch_values(options, :metrics).each do |metric|
        run 'measure', target, metric, "--until=#{options[:until] || measure_until || :now}", parallel: true
        fetch_values(options, :normalizations, optional: true).each do |normalization|
          run 'normalize', target, metric, "--method=#{normalization}", parallel: true
        end
      end
    end
  end

  def normalize(options = {})
    fetch_values(options, :targets).each do |target|
      fetch_values(options, :metrics).each do |metric|
        fetch_values(options, :methods).each do |method|
          run 'normalize', target, metric, "--method=#{method}", parallel: true
        end
      end
    end
  end

  private

  def fetch_values(options, key, optional: false)
    multiple, single = key.to_s.pluralize.to_sym, key.to_s.singularize.to_sym
    raise("#{single} already given") if options.key?(multiple) && options.key?(single)
    values = Array.wrap options.fetch(multiple, [])
    values = [options[single]] if options.key?(single) && values.empty?
    optional || !values.empty? ? values : raise("no #{single} given")
  end
end

class Round
  attr_accessor :file, :options

  def initialize(file, options = {})
    self.file, self.options = file.dup, options.dup
    AutoColor.disable on: self unless self.options[:color]
  end

  def load!
    space, round = Object.new, self
    space.define_singleton_method(:run) { |*a| round.run *a }
    space.singleton_class.include Syntax
    space.measure_until = options[:until]
    space.instance_eval { load File.expand_path '../../Extisefile', __FILE__ }
    SafeEval::IO.read_and_safe_eval File.open_or(file), context: space
  end

  def run(*a)
    a = a.flatten.compact
    a, o = *(a.last.is_a?(Hash) ? [a[0..-2], a.last] : [a, {}])
    a += %W(--parallel=#{options[:parallel]} --parallel-worker=#{options[:parallel_worker]}) if o[:parallel]
    a << '--color'
    c, t, f = a * ' ', Time.now.strftime('%Y%m%d-%H%M%S-%L'), file.is_a?(IO) ? nil : File.basename(file, '.rb')
    @log_directory ||= File.expand_path File.join(%W(.. .. log #{t}#{'_' + f if f})), __FILE__
    FileUtils.mkpath @log_directory
    begin
      l = File.join @log_directory, "#{t}_#{a[0]}.log"
      log = File.open l, 'a'
      File.write l, "#{t.black}\n\n#{c.white}\n\n"
      p = a.reject { |x| x =~ /--(parallel|(no-)?(color|sort|verbose)|trim|quiet)/ }
      p << 'â€¦' if p.size != a.size
      puts "#{p * ' '}".cyan unless options[:quiet]
      s = Open3.popen3(File.expand_path File.join(%W(.. #{c})), __FILE__) do |input, output, error, status|
        outputs, errors = [(self if !o[:silent] && options[:verbose] && !options[:quiet]), log].compact, [log]
        threads = [Thread.new { output.each { |l| outputs.each { |s| s.print l }}}]
        threads << Thread.new { error.each { |l| errors.each { |s| s.print l }}}
        threads.each &:join
        [input, output, error].each &:close
        status.value
      end
      puts s.success? ? 'success'.green : 'failure'.red if options[:verbose] unless options[:quiet]
    ensure
      log.close if log
      fix t, c, l
    end
  end

  private

  def fix(t, c, l)
    s = File.read l
    File.write l, Colored.decolorize(s)
    return unless options[:color]
    o = <<-HTML.strip_heredoc
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="utf-8">
          <title><% title %></title>
        </head>
        <body style="margin: 1rem; font-size: 14px">
          <pre style="display: inline-block; margin: 0; padding: 1rem; background: #000; color: #bbb"><% content %></pre>
        </body>
      </html>
    HTML
    o = o.gsub(/<%\s*title\s*%>/, "#{t} #{c}").gsub(/<%\s*content\s*%>/, Colored.decolorize(s, escape: Colored::HTML))
    d = File.join(File.dirname(l), 'screenshots').tap { |d| FileUtils.mkpath d }
    File.write File.join(d, "#{File.basename(l)}.html"), o
  end
end

o = Hash[%i(until parallel parallel_worker color verbose quiet).zip [u, n, w, c, v, q]]

p.each do |f|
  inform f if v && !q && !f.is_a?(IO)
  Round.new(f, o).load!
end
