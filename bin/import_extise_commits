#!/usr/bin/env ruby
require_relative 'common' and load_extise!

d, n, w = nil, 4, :thread
c, s, t, v, q, r = true, false, 80, true, false, nil

ARGV.bind_and_parse! to: :locals do
  use '[<options>] <repository>'
  opt 'd -d --directory=<path>'
  opt 'n    --parallel[=<count:Integer>]'
  opt 'w    --parallel-worker=(process|thread)'
  opt 'c -c --[no-]color'
  opt 's -s --[no-]sort'
  opt 't -t --trim[=<length:Integer>]'
  opt 'v -v --[no-]verbose'
  opt 'q -q --quiet'
  arg 'r <repository>'
end

d ||= File.expand_path('../../../data/git.eclipse.org', __FILE__)
n = 0 unless options.assigned? :n
v, q = false, true unless n.zero?

AutoColor.disable on: self unless c

include Extisimo

def walk_files(git, tree, path = '.', &block)
  tree.each_blob { |f| block.call f.merge(path: File.join(path, f[:name]).sub(/\A\.\//, '')) }
  tree.each_tree { |t| walk_files git, git.lookup(t[:oid]), File.join(path, t[:name]), &block }
end

# NOTE: since the sum of interactions is far greater than the sum commits,
# we first process commits and leave interactions for later processing

repository = Repository.find_by name: r

abort "#{Repository}:? not found by #{r}".red unless repository

dump_record repository, :repository

path = File.join d, repository.name
git = Rugged::Repository.new path

git.checkout 'master'

process git.walk('HEAD', Rugged::SORT_REVERSE).to_a, count: n, worker: w, progress: !n.zero? do |c|
  author = User.joins(:bugs_eclipse_org_user).find_by 'login_name = ? OR realnames @> ?', c.author[:name], "{#{c.author[:name]}}"

  # NOTE: skip commits for users who can not be identified, i.e. with no tasks or interactions

  unless author
    warn "#{User}:? not found by #{c.author[:name]}".magenta
    next
  end

  commit = persist(Commit, repository: repository, identifier: c.oid) do |r|
    r.author = author
    r.submitted_at = c.time.utc
  end

  dump_record commit, :commit, 1

  files, sources = [], ''

  walk_files(git, c.tree) do |f|

    # NOTE: select only Java files to process

    next unless f[:name].end_with? '.java'

    files << f
    sources << "# #{f[:path]}\n#{git.lookup(f[:oid]).content}"
  end

  extractor, blocks = 'TypePositionExtractor', nil

  puts "#{'  ' * 2}" << "#{Extise.command extractor} < â€¦".cyan if v unless q

  # NOTE: extract Java type declarations for all files at once

  Extise.stream(function: extractor, input: sources) do |o|
    blocks = Extise::Parser.parse_blocks o
  end or abort("#{Commit}:#{commit.id} unexpected failure extracting elements".red)

  abort "#{Commit}:#{commit.id} no elements extracted".red if blocks.nil?

  blocks = blocks.inject({}) { |h, b| (h[b[:file]] ||= []) << b; h }

  abort "#{Commit}:#{commit.id} some elements not extracted".red if blocks.count < files.count

  files.each do |f|

    # NOTE: select only top level Java type declarations

    blocks[f[:path]].select! { |b| b[:path] !~ /\// }

    if blocks[f[:path]].empty?
      warn "#{Commit}:#{commit.id} no suitable elements in #{f[:path]}".magenta
      next
    end

    blocks[f[:path]].each do |b|
      element = persist(Element, commit: commit, identifier: f[:oid], path: b[:path]) do |r|
        r.file = f[:path]
        r.offset = b[:offset]
        r.length = b[:length]
        r.line = b[:line]
      end

      dump_record element, :element, 2
    end
  end
end
